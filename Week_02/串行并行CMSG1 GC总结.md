# 串行/并行/CMS/G1 GC总结

gc 标记阶段的时间，与堆内存大小，对象的总数没有直接关系，由存活对象的数量决定。

标记-清除 算法：速度快，但是内存是碎片化的，对于像数组这种需要使用连续内存的，可能出现有内存却无法分配的情况。

复制算法 不会产生碎片，但需要占用额外的空间。

整理算法： 需要对内存进行整理，耗时较长，但能很好的使用内存空间。

CMC GC的设计目标是避免在老年代垃圾收集时出现长时间的卡顿。

## 串行GC

串行GC，会全线暂停（STW）来对对像进行标记，来做GC

暂停时间长，动不动卡死，不能有效的使用多核

## 并行GC

java8默认为并行GC，并行GC会单独分配线程用于GC,不会影响其他线程上任务的执行，不会出现暂停的情况（更正，暂停的时间很短？）。

![image-20201028210431937](C:\Users\卢昱奇\AppData\Roaming\Typora\typora-user-images\image-20201028210431937.png)

当降低堆的初始内存大小和堆内存的最大值后，生成对象的次数减少，FullGC发生的次数增多。为什么？首先创建的新对象会放在young区的eden区，young区发生GC的时机？创建对象时分配内存失败。而young区采用的算法为：标记-复制，从根对象出发进行标记，将标记对象从eden和（s1或s0）移动到空的生还区（s0或s1）,然后进行清除操作。（标记复制算法决定了s1和s0有一个区必然是空的）

另外，从日志中也能看到，程序执行中随着时间的推移，young区内存的使用量在不断上升，

from?to?

？Full GC的触发时机

是堆内存的使用量超过一定比例？young区和old区的内存比例为1：3

晋升机制，经过一定次数（可以进行设置）young GC后，依然还存活的对象会移动到old区。

从日志中可以看出，发生Full GC的时候，young区清空，old区内存使用量下降（Full GC过程：年轻代进行标记-复制算法，老年代进行标记-清理-整理算法）

GC时，MetaSpace未发生变化，MetaSpace位于非堆，而GC只针对堆内存进行操作。



若不配置Xms的，首先第一次发生youngGC时，堆内存是比较小的，(64m左右，，配置Xms的话是131m左右)



## CMS 

CMSGC 初始标记的时间非常短，是因为只标记了根对象出发的第一个对象

只有初始的预标记会暂停极短的时间，其他过程是并行执行的。

并发标记占CPU核心数的1/4，（不能太多，会影响正常线程的执行效率）

## G1

不在区分年轻代和老年代，动态进行分配。一部分算法与CMS相同。

![](C:\Users\卢昱奇\AppData\Roaming\Typora\typora-user-images\image-20201025204949619.png)

